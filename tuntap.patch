*** klh10-2.0h/bld/lnx86/00build	2005-02-22 02:47:02.000000000 -0500
--- klh10-2.0i/bld/lnx86/00build	2005-09-10 01:05:48.000000000 -0400
***************
*** 1,2 ****
  #!/bin/sh
! make base-kl CONFFLAGS_AUX=-DKLH10_I_CIRC=1 LDFLAGS=-static
--- 1,2 ----
  #!/bin/sh
! make -k base-kl CONFFLAGS_AUX="-DKLH10_NET_TUN=1 -DKLH10_I_CIRC=1"
*** klh10-2.0h/src/dpimp.c	2003-02-23 13:07:35.000000000 -0500
--- klh10-2.0i/src/dpimp.c	2005-09-11 10:14:55.000000000 -0400
***************
*** 279,285 ****
--- 279,289 ----
  struct in_addr ihost_ip;	/* IMP/Native host IP addr, net order */
  struct in_addr ihost_nm;	/* IMP/Native host subnet netmask, net order */
  struct in_addr ihost_net;	/* IMP/Native host net #, net order */
+ #if KLH10_NET_TUN
+ struct in_addr tun_ip;		/* IP addr of tunnel */
+ #else
  struct in_addr gwdef_ip;	/* IP addr of default prime gateway */
+ #endif
  
  struct ether_addr ehost_ea;	/* Emulated host ethernet addr */
  struct ether_addr ihost_ea;	/* IMP/Native host ethernet addr */
***************
*** 497,503 ****
--- 501,511 ----
         shared DP area.
      */
      memcpy((void *)&ehost_ip, dpimp->dpimp_ip, 4);	/* Host IP addr */
+ #if KLH10_NET_TUN
+     memcpy((void *)&tun_ip, dpimp->dpimp_tun, 4);	/* Tunnel addr */
+ #else
      memcpy((void *)&gwdef_ip, dpimp->dpimp_gw, 4);	/* Default GW addr */
+ #endif
      memcpy((void *)&ehost_ea, dpimp->dpimp_eth, 6);	/* Host Ether addr */
  
      /* IMP must always have IP address specified! */
***************
*** 555,560 ****
--- 563,569 ----
  	char ipbuf[OSN_IPSTRSIZ];
  	char eabuf[OSN_EASTRSIZ];
  
+ #if !KLH10_NET_TUN
  	dbprintln("ifc \"%s\" => ether %s",
  		  dpimp->dpimp_ifnam,
  		  eth_adrsprint(eabuf, (unsigned char *)&ihost_ea));
***************
*** 564,573 ****
  		  ip_adrsprint(ipbuf, (unsigned char *)&ihost_nm));
  	dbprintln("  net %s",
  		  ip_adrsprint(ipbuf, (unsigned char *)&ihost_net));
- 	dbprintln("  HOST: %s",
- 		  ip_adrsprint(ipbuf, (unsigned char *)&ehost_ip));
  	dbprintln("  gwdef %s",
  		  ip_adrsprint(ipbuf, (unsigned char *)&gwdef_ip));
      }
  
      /* Init ARP stuff - ensure can talk to native host.
--- 573,588 ----
  		  ip_adrsprint(ipbuf, (unsigned char *)&ihost_nm));
  	dbprintln("  net %s",
  		  ip_adrsprint(ipbuf, (unsigned char *)&ihost_net));
  	dbprintln("  gwdef %s",
  		  ip_adrsprint(ipbuf, (unsigned char *)&gwdef_ip));
+ #else
+ 	dbprintln("ifc \"%s\"",
+ 		  dpimp->dpimp_ifnam);
+ 	dbprintln("  tun %s",
+ 		  ip_adrsprint(ipbuf, (unsigned char *)&tun_ip));
+ #endif
+ 	dbprintln("  HOST %s",
+ 		  ip_adrsprint(ipbuf, (unsigned char *)&ehost_ip));
      }
  
      /* Init ARP stuff - ensure can talk to native host.
***************
*** 622,627 ****
--- 637,644 ----
  {
      struct ifreq ifr;
  
+ #if !KLH10_NET_TUN
+ 
  #if 1 /* This code is identical to dpni20 - merge in osdnet? */
  
      /* Ensure network device name, if specified, isn't too long */
***************
*** 678,683 ****
--- 695,702 ----
      if (gwdef_ip.s_addr == -1 || gwdef_ip.s_addr == 0)
  	efatal(1, "No default prime gateway specified");
  
+ #endif
+ 
      /* Set up appropriate net fd and packet filter.
      ** Should also determine interface's ethernet addr, if possible,
      ** and set ihost_ea.
***************
*** 690,701 ****
--- 709,726 ----
      npf.osnpf_rdtmo = dpimp->dpimp_rdtmo;
      npf.osnpf_backlog = dpimp->dpimp_backlog;
      npf.osnpf_ip.ia_addr = ehost_ip;
+ #if KLH10_NET_TUN
+     npf.osnpf_tun.ia_addr = tun_ip;
+ #endif
      /* Ether addr is both a potential arg and a returned value;
         the packetfilter open may use and/or change it.
      */
      ea_set(&npf.osnpf_ea, dpimp->dpimp_eth);	/* Set requested ea if any */
      pffd = osn_pfinit(&npf, (void *)dpimp);	/* Will abort if fails */
      ea_set(&ihost_ea, &npf.osnpf_ea);		/* Copy actual ea if one */
+ #if KLH10_NET_TUN
+     tun_ip = npf.osnpf_tun.ia_addr;		/* Copy actual tun if any */
+ #endif
    }
  }
  
***************
*** 1730,1736 ****
--- 1755,1765 ----
      /* Hack to set host/imp value as properly as possible. */
      memcpy((char *)&haddr.ia_octet[0], pp + IPBOFF_SRC, 4);
      if ((haddr.ia_addr.s_addr & ihost_nm.s_addr) != ihost_net.s_addr) {
+ #if !KLH10_NET_TUN
  	haddr.ia_addr = gwdef_ip;	/* Not local, use default GW */
+ #else
+ 	haddr.ia_addr = tun_ip;		/* Not local, use tunnel end */
+ #endif
      }
  
      ihobuf[SIH_HSIZ+SIL_HST]  = haddr.ia_octet[1];
*** klh10-2.0h/src/dpimp.h	2001-11-19 05:45:49.000000000 -0500
--- klh10-2.0i/src/dpimp.h	2005-08-16 20:05:22.000000000 -0400
***************
*** 106,111 ****
--- 106,112 ----
      unsigned char dpimp_eth[6];	/* CD Ethernet address of interface */
      unsigned char dpimp_ip[4];	/* C 10's IP address to filter on, if shared */
      unsigned char dpimp_gw[4];	/* C Default GW address for IMP to use */
+     unsigned char dpimp_tun[4];	/* CD Tunnel address for IMP */
      int dpimp_inoff;		/* C Offset in buffer of input (I->H) data */
      int dpimp_outoff;		/* D Offset in buffer of output (H->I) data */
      int dpimp_backlog;		/* C Max sys backlog of rcvd packets */
*** klh10-2.0h/src/dpni20.c	2003-02-23 13:07:50.000000000 -0500
--- klh10-2.0i/src/dpni20.c	2005-09-09 20:50:47.000000000 -0400
***************
*** 177,183 ****
--- 177,188 ----
  struct dp_s dp;			/* Device-Process struct for DP ops */
  
  struct in_addr ehost_ip;	/* Emulated host IP addr, net order */
+ #if 0
  struct in_addr ihost_ip;	/* Native host's IP addr, net order */
+ #endif
+ #if KLH10_NET_TUN
+ struct in_addr tun_ip;		/* Tunnel IP addr, net order */
+ #endif
  struct ether_addr ihost_ea;	/* Native host ether addr for selected ifc */
  
  /* Debug flag reference.  Use DBGFLG within functions that have "dpni";
***************
*** 383,396 ****
      net_init(dpni);
  
      /* Make this a status (rather than debug) printout? */
!     if (DBGFLG) {
  	char sbuf[OSN_IPSTRSIZ+OSN_EASTRSIZ];	/* Lazily ensure big enough */
  
  	dbprintln("ifc \"%s\" => ether %s",
  		  dpni->dpni_ifnam,
  		  eth_adrsprint(sbuf, (unsigned char *)&ihost_ea));
  	dbprintln("  addr  %s",
  		  ip_adrsprint(sbuf, (unsigned char *)&ihost_ip));
  	dbprintln("  VHOST %s",
  		  ip_adrsprint(sbuf, (unsigned char *)&ehost_ip));
      }
--- 388,407 ----
      net_init(dpni);
  
      /* Make this a status (rather than debug) printout? */
!     if (swstatus) {
  	char sbuf[OSN_IPSTRSIZ+OSN_EASTRSIZ];	/* Lazily ensure big enough */
  
  	dbprintln("ifc \"%s\" => ether %s",
  		  dpni->dpni_ifnam,
  		  eth_adrsprint(sbuf, (unsigned char *)&ihost_ea));
+ #if 0
  	dbprintln("  addr  %s",
  		  ip_adrsprint(sbuf, (unsigned char *)&ihost_ip));
+ #endif
+ #if KLH10_NET_TUN
+ 	dbprintln("  tun  %s",
+ 		  ip_adrsprint(sbuf, (unsigned char *)&tun_ip));
+ #endif
  	dbprintln("  VHOST %s",
  		  ip_adrsprint(sbuf, (unsigned char *)&ehost_ip));
      }
***************
*** 445,450 ****
--- 456,465 ----
      /* Get the IP address we need to filter on, if shared */
      memcpy((char *)&ehost_ip, (char *)&dpni->dpni_ip, 4);
  
+ #if KLH10_NET_TUN
+     /* Get the IP address for the tunnel, if specified */
+     memcpy((char *)&tun_ip, (char *)&dpni->dpni_tun, 4);
+ #else
      /* Ensure network device name, if specified, isn't too long */
      if (dpni->dpni_ifnam[0] && (strlen(dpni->dpni_ifnam)
  		>= sizeof(ifr.ifr_name))) {
***************
*** 476,481 ****
--- 491,497 ----
  		dbprintln("Using default interface \"%s\"", dpni->dpni_ifnam);
  	}
      }
+ #endif
  
      /* Now set remaining stuff */
  
***************
*** 490,501 ****
--- 506,523 ----
      npf.osnpf_rdtmo = dpni->dpni_rdtmo;
      npf.osnpf_backlog = dpni->dpni_backlog;
      npf.osnpf_ip.ia_addr = ehost_ip;
+ #if KLH10_NET_TUN
+     npf.osnpf_tun.ia_addr = tun_ip;
+ #endif
      /* Ether addr is both a potential arg and a returned value;
         the packetfilter open may use and/or change it.
      */
      ea_set(&npf.osnpf_ea, dpni->dpni_eth);	/* Set requested ea if any */
      pffd = osn_pfinit(&npf, (void *)dpni);	/* Will abort if fails */
      ea_set(&ihost_ea, &npf.osnpf_ea);		/* Copy actual ea */
+ #if KLH10_NET_TUN
+     tun_ip = npf.osnpf_tun.ia_addr;		/* Get actual tunnel addr */
+ #endif
    }
  
      /* Now set any return info values in shared struct.
***************
*** 1441,1450 ****
  	    cnt = data.len;
  	/* Else cnt must be -1 as call failed */
      }
- #elif KLH10_NET_NIT || KLH10_NET_PFLT || KLH10_NET_LNX
- 	cnt = read(pffd, buff, max);
  #elif KLH10_NET_BPF
  	cnt = read(pffd, tbuff, tmax);
  #endif
  	if (cnt <= cmin) {		/* Must get enough for ether header */
  
--- 1463,1472 ----
  	    cnt = data.len;
  	/* Else cnt must be -1 as call failed */
      }
  #elif KLH10_NET_BPF
  	cnt = read(pffd, tbuff, tmax);
+ #else
+ 	cnt = read(pffd, buff, max);
  #endif
  	if (cnt <= cmin) {		/* Must get enough for ether header */
  
***************
*** 1509,1515 ****
  		continue;		/* Drop packet, continue reading */
  	}
  #endif /* KLH10_NET_LNX */
! #if KLH10_NET_NIT || KLH10_NET_DLPI || KLH10_NET_PFLT || KLH10_NET_LNX
  #if 0
  	if (DBGFLG)
  	    if (((struct ether_header *)buff)->ether_type == htons(ETHERTYPE_ARP))
--- 1531,1537 ----
  		continue;		/* Drop packet, continue reading */
  	}
  #endif /* KLH10_NET_LNX */
! #if !KLH10_NET_BPF
  #if 0
  	if (DBGFLG)
  	    if (((struct ether_header *)buff)->ether_type == htons(ETHERTYPE_ARP))
***************
*** 1521,1529 ****
  	if (DBGFLG)
  	    dbprint("sent RPKT");
  
! #endif /* KLH10_NET_NIT || KLH10_NET_DLPI || KLH10_NET_PFLT || KLH10_NET_LNX */
  
- #if KLH10_NET_BPF
  	/* Screwy BPF algorithm requires more overhead because there's
  	   no way to ensure only one packet is read at a time; the call
  	   may return a buffer of several packets, each of which must
--- 1543,1550 ----
  	if (DBGFLG)
  	    dbprint("sent RPKT");
  
! #else
  
  	/* Screwy BPF algorithm requires more overhead because there's
  	   no way to ensure only one packet is read at a time; the call
  	   may return a buffer of several packets, each of which must
*** klh10-2.0h/src/dpni20.h	2001-11-10 16:29:01.000000000 -0500
--- klh10-2.0i/src/dpni20.h	2005-08-16 20:05:22.000000000 -0400
***************
*** 52,57 ****
--- 52,58 ----
      char dpni_ifnam[16];	/* CD Interface name if any */
      unsigned char dpni_eth[6];	/* CD Ethernet address of interface */
      unsigned char dpni_ip[4];	/* C 10's IP address to filter on, if shared */
+     unsigned char dpni_tun[4];	/* CD host's IP address on tunnel */
      int dpni_backlog;		/* C Max sys backlog of rcvd packets */
      int dpni_dedic;		/* C TRUE if dedicated ifc, else shared */
      int dpni_decnet;		/* C TRUE to seize DECNET packets, if shared */
diff -r -c --exclude='*.orig' --unidirectional-new-file klh10-2.0h/src/dvlhdh.c klh10-2.0i/src/dvlhdh.c
*** klh10-2.0h/src/dvlhdh.c	2001-11-19 05:47:54.000000000 -0500
--- klh10-2.0i/src/dvlhdh.c	2005-08-16 20:05:22.000000000 -0400
***************
*** 103,108 ****
--- 103,109 ----
      int lh_rdtmo;	/* # secs to timeout on packetfilter reads */
      unsigned char lh_ipadr[4];	/* KLH10 IP address to filter on */
      unsigned char lh_gwadr[4];	/* Gateway IP address to use when needed */
+     unsigned char lh_tunadr[4];	/* Tunnel IP address on local side */
      unsigned char lh_ethadr[6];	/* Ether address to use, if dedicated */
  
      char *lh_dpname;	/* Pointer to dev process pathname */
***************
*** 171,176 ****
--- 172,178 ----
  \
      prmdef(LHDHP_IP, "ipaddr"),   /* IP address of KLH10, if shared */\
      prmdef(LHDHP_GW, "gwaddr"),   /* IP address of prime GW to use */\
+     prmdef(LHDHP_TUN,"tunaddr"),  /* IP address of local side of tunnel */\
      prmdef(LHDHP_EN, "enaddr"),   /* Ethernet address to use (override) */\
      prmdef(LHDHP_IFC,"ifc"),      /* Ethernet interface name */\
      prmdef(LHDHP_BKL,"backlog"),/* Max bklog for rcvd pkts (else sys deflt) */\
***************
*** 301,306 ****
--- 303,315 ----
  		break;
  	    continue;
  
+ 	case LHDHP_TUN:		/* Parse as IP address: u.u.u.u */
+ 	    if (!prm.prm_val)
+ 		break;
+ 	    if (!parip(prm.prm_val, &lh->lh_tunadr[0]))
+ 		break;
+ 	    continue;
+ 
  	case LHDHP_EN:		/* Parse as EN address in hex */
  	    if (!prm.prm_val)
  		break;
***************
*** 1057,1062 ****
--- 1066,1073 ----
  		lh->lh_ipadr, 4);
      memcpy((char *)dpc->dpimp_gw,	/* Set our GW address for IMP */
  		lh->lh_gwadr, 4);
+     memcpy((char *)dpc->dpimp_tun,	/* Set our IP address for tunnel */
+ 		lh->lh_tunadr, 4);	/* (all zero if none) */
      memcpy(dpc->dpimp_eth,		/* Set EN address if any given */
  		lh->lh_ethadr, 6);	/* (all zero if none) */
  
*** klh10-2.0h/src/dvni20.c	2001-11-10 16:29:03.000000000 -0500
--- klh10-2.0i/src/dvni20.c	2005-08-16 20:05:22.000000000 -0400
***************
*** 157,162 ****
--- 157,163 ----
      int ni_lsapf;	/* TRUE to filter on LSAP addr (if shared) */
      int ni_lsap;	/* LSAP src/dst address for above */
      unsigned char ni_ipadr[4];	/* KLH10 IP address to filter (if shared) */
+     unsigned char ni_tunadr[4];	/* Tunnel IP address (if masquerading) */
      int32 ni_c3dly;		/* Initial-cmd delay in ticks */
      int32 ni_c3dlyct;		/* Countdown (no delay if 0) */
  
***************
*** 294,299 ****
--- 295,301 ----
      prmdef(NIP_BKL,"backlog"),/* Max bklog for rcvd pkts (else sys default) */\
      prmdef(NIP_DED,"dedic"),    /* TRUE= Ifc dedicated (else shared) */\
      prmdef(NIP_IP, "ipaddr"),   /* IP address of KLH10, if shared */\
+     prmdef(NIP_TUN, "tunaddr"), /* IP address of local end of tunnel */\
      prmdef(NIP_DEC,"decnet"),   /* TRUE= if shared, seize DECNET pkts */\
      prmdef(NIP_ARP,"doarp"),    /* TRUE= if shared, do ARP hackery */\
      prmdef(NIP_LSAP,"lsap"),    /* Set= if shared, filter on LSAP pkts */\
***************
*** 391,396 ****
--- 393,405 ----
  		break;
  	    continue;
  
+ 	case NIP_TUN:		/* Parse as IP address: u.u.u.u */
+ 	    if (!prm.prm_val)
+ 		break;
+ 	    if (!parip(prm.prm_val, &ni->ni_tunadr[0]))
+ 		break;
+ 	    continue;
+ 
  	case NIP_EN:		/* Parse as EN address in hex */
  	    if (!prm.prm_val)
  		break;
***************
*** 711,716 ****
--- 720,727 ----
  	dpc->dpni_ifnam[0] = '\0';	/* No specific interface */
      memcpy((char *)dpc->dpni_ip,	/* Set our IP address for filter */
  		ni->ni_ipadr, 4);
+     memcpy((char *)dpc->dpni_tun,	/* Set IP address for tunnel */
+ 		ni->ni_tunadr, 4);
      memcpy(dpc->dpni_eth,		/* Set EN address if any given */
  		ni->ni_ethadr, 6);	/* (all zero if none) */
  
*** klh10-2.0h/src/Makefile.mk	2005-02-22 02:16:14.000000000 -0500
--- klh10-2.0i/src/Makefile.mk	2005-08-16 20:05:22.000000000 -0400
***************
*** 302,308 ****
  			-DKLH10_DEV_DPRPXX=1 \
  			-DKLH10_DEV_DPIMP=1 \
  		-DKLH10_SIMP=0 \
- 		-DKLH10_NET_TUN=SYS_FREEBSD \
  		-DKLH10_MEM_SHARED=1 \
  		$(TINTFLAGS) \
  		$(DINTFLAGS) \
--- 302,307 ----
*** klh10-2.0h/src/osdnet.c	2005-04-28 18:01:04.000000000 -0400
--- klh10-2.0i/src/osdnet.c	2005-09-11 11:12:41.000000000 -0400
***************
*** 812,818 ****
  	ea_set(def, ifdev.default_pa);
    }
  
! #elif KLH10_NET_LNX
    {
      int ownsock = FALSE;
      struct ifreq ifr;
--- 812,818 ----
  	ea_set(def, ifdev.default_pa);
    }
  
! #elif CENV_SYS_LINUX
    {
      int ownsock = FALSE;
      struct ifreq ifr;
***************
*** 1131,1137 ****
  	    char *ifnam,	/* Interface name */
  	    unsigned char *newpa)	/* New ether address */
  {
! #if CENV_SYS_DECOSF || KLH10_NET_LNX \
  		    || (CENV_SYS_FREEBSD && defined(SIOCSIFLLADDR))
  
      /* Common preamble code */
--- 1131,1137 ----
  	    char *ifnam,	/* Interface name */
  	    unsigned char *newpa)	/* New ether address */
  {
! #if CENV_SYS_DECOSF || CENV_SYS_LINUX \
  		    || (CENV_SYS_FREEBSD && defined(SIOCSIFLLADDR))
  
      /* Common preamble code */
***************
*** 1162,1168 ****
  	return FALSE;
      }
  
! # elif KLH10_NET_LNX
  
      /* Address family must match what device thinks it is, so find that
         out first... sigh.
--- 1162,1168 ----
  	return FALSE;
      }
  
! # elif CENV_SYS_LINUX
  
      /* Address family must match what device thinks it is, so find that
         out first... sigh.
***************
*** 1225,1231 ****
  	    int delf,
  	    unsigned char *pa)
  {
! #if CENV_SYS_DECOSF || KLH10_NET_LNX || CENV_SYS_FREEBSD
  
      /* Common preamble code */
      int ownsock = FALSE;
--- 1225,1231 ----
  	    int delf,
  	    unsigned char *pa)
  {
! #if CENV_SYS_DECOSF || CENV_SYS_LINUX || CENV_SYS_FREEBSD
  
      /* Common preamble code */
      int ownsock = FALSE;
***************
*** 1616,1624 ****
--- 1616,1629 ----
  {
      int allowextern = TRUE;	/* For now, always try for external access */
      int fd;
+ #if CENV_SYS_LINUX		/* [BV: tun support for Linux] */
+     struct ifreq ifr;
+     char ifnam[IFNAMSIZ];
+ #else
      char tunname[sizeof "/dev/tun000"];
      char *ifnam = tunname + sizeof("/dev/")-1;
      int i = -1;
+ #endif
      char ipb1[OSN_IPSTRSIZ];
      char ipb2[OSN_IPSTRSIZ];
      struct ifent *ife = NULL;	/* Native host's default IP interface if one */
***************
*** 1628,1660 ****
  
      /* Remote address is always that of emulated machine */
      ipremote = osnpf->osnpf_ip.ia_addr;
  
!     /* Local address is that of hardware machine if we want to permit
!        external access.  If not, it doesn't matter (and may not even
!        exist, if there is no hardware interface)
!     */
!     if (allowextern) {
! 	if (osn_iftab_init(IFTAB_IPS) && (ife = osn_ipdefault())) {
! 	    iplocal = ife->ife_ipia;
! 	} else {
! 	    error("Cannot find default IP interface for host");
! 	    allowextern = FALSE;
! 	}
!     }
!     if (!allowextern) {
! 	/* Make up bogus IP address for internal use */
! 	memcpy((char *)&iplocal, ipremset, 4);
      }
  
      if (DP_DBGFLG)
  	dbprint("Opening TUN device");
  
      do {
  	sprintf(tunname, "/dev/tun%d", ++i);
      } while ((fd = open(tunname, O_RDWR)) < 0 && errno == EBUSY);
  
      if (fd < 0)
  	esfatal(1, "Couldn't open tunnel device %s", tunname);
  
      if (DP_DBGFLG)
  	dbprintln("Opened %s, configuring for local %s, remote %s",
--- 1633,1689 ----
  
      /* Remote address is always that of emulated machine */
      ipremote = osnpf->osnpf_ip.ia_addr;
+     iplocal = osnpf->osnpf_tun.ia_addr;
  
!     /* Local address can be set explicitly if we plan to do full IP
!        masquerading. */
!     if (memcmp((char *)&iplocal, "\0\0\0\0", IP_ADRSIZ) == 0) {
!       /* Local address is that of hardware machine if we want to permit
! 	 external access.  If not, it doesn't matter (and may not even
! 	 exist, if there is no hardware interface)
!       */
!       if (allowextern) {
! 	  if (osn_iftab_init(IFTAB_IPS) && (ife = osn_ipdefault())) {
! 	      iplocal = ife->ife_ipia;
! 	  } else {
! 	      error("Cannot find default IP interface for host");
! 	      allowextern = FALSE;
! 	  }
!       }
!       if (!allowextern) {
! 	  /* Make up bogus IP address for internal use */
! 	  memcpy((char *)&iplocal, ipremset, 4);
!       }
!       osnpf->osnpf_tun.ia_addr = iplocal;
      }
  
      if (DP_DBGFLG)
  	dbprint("Opening TUN device");
  
+ #if CENV_SYS_LINUX		/* [BV: Linux way] */
+     if ((fd = open("/dev/net/tun", O_RDWR)) < 0) /* get a fresh device */
+       esfatal(0, "Couldn't open tunnel device /dev/net/tun");
+     memset(&ifr, 0, sizeof(ifr));
+ #if OSN_USE_IPONLY
+     ifr.ifr_flags = IFF_TUN | IFF_NO_PI; /* TUN (no Ethernet headers), no pkt info */
+ #else
+     ifr.ifr_flags = IFF_TAP | IFF_NO_PI; /* TAP (yes Ethernet headers), no pkt info */
+ #endif
+     if (ioctl(fd, TUNSETIFF, (void *) &ifr) < 0) /* turn it on */
+       esfatal(0, "Couldn't set tun device");
+     strcpy(ifnam, ifr.ifr_name); /* get device name (typically "tun0") */
+ #else
      do {
+ #if OSN_USE_IPONLY
  	sprintf(tunname, "/dev/tun%d", ++i);
+ #else
+ 	sprintf(tunname, "/dev/tap%d", ++i);
+ #endif
      } while ((fd = open(tunname, O_RDWR)) < 0 && errno == EBUSY);
  
      if (fd < 0)
  	esfatal(1, "Couldn't open tunnel device %s", tunname);
+ #endif
  
      if (DP_DBGFLG)
  	dbprintln("Opened %s, configuring for local %s, remote %s",
***************
*** 1662,1667 ****
--- 1691,1697 ----
  	    ip_adrsprint(ipb1, (unsigned char *)&iplocal),
  	    ip_adrsprint(ipb2, (unsigned char *)&ipremote));
  
+     strcpy(osnpf->osnpf_ifnam, ifnam);
  
      /* Activate TUN device.
         First address is "local" -- doesn't matter if all we care about is
***************
*** 1691,1696 ****
--- 1721,1743 ----
  	esfatal(1, "osn_pfinit: ifconfig failed to initialize tunnel device?");
      }
    }
+ #elif CENV_SYS_LINUX		/* [BV: Linux tun device] */
+ 				/* "Hacky" but simple method */
+   {
+     char cmdbuff[128];
+     int res;
+ 
+     /* ifconfig DEV IPLOCAL pointopoint IPREMOTE */
+     sprintf(cmdbuff, "ifconfig %s %s pointopoint %s up",
+ 	    ifnam,
+ 	    ip_adrsprint(ipb1, (unsigned char *)&iplocal),
+ 	    ip_adrsprint(ipb2, (unsigned char *)&ipremote));
+     if (DP_DBGFLG)
+       dbprintln("running \"%s\"",cmdbuff);
+     if ((res = system(cmdbuff)) != 0) {
+ 	esfatal(1, "osn_pfinit: ifconfig failed to initialize tunnel device?");
+     }
+   }
  #else
    {
      /* Internal method */
***************
*** 1770,1777 ****
  	/* Return that as our ether address */
  	ea_set((char *)&osnpf->osnpf_ea, ife->ife_ea);
      } else {
! 	/* Assume no useful ether addr */
  	ea_clr((char *)&osnpf->osnpf_ea);
      }
  
      if (DP_DBGFLG)
--- 1817,1835 ----
  	/* Return that as our ether address */
  	ea_set((char *)&osnpf->osnpf_ea, ife->ife_ea);
      } else {
! 	/* ARP hackery will be handled by IP masquerading and packet forwarding. */
! #if 1 /*OSN_USE_IPONLY*/ /* TOPS-20 does not like NI20 with made up address? */
! 	/* Assume no useful ether addr for tun interface. */
  	ea_clr((char *)&osnpf->osnpf_ea);
+ #else
+         /* Assign requested address to tap interface or get kernel assigned one. */
+         if (memcmp((char *)&osnpf->osnpf_ea, "\0\0\0\0\0\0", ETHER_ADRSIZ) == 0) {
+           osn_ifeaget(-1, ifnam, (unsigned char *)&osnpf->osnpf_ea, NULL);
+         }
+         else {
+           osn_ifeaset(-1, ifnam, (unsigned char *)&osnpf->osnpf_ea);
+         }
+ #endif
      }
  
      if (DP_DBGFLG)
*** klh10-2.0h/src/osdnet.h	2001-11-19 05:34:01.000000000 -0500
--- klh10-2.0i/src/osdnet.h	2005-08-16 20:05:22.000000000 -0400
***************
*** 69,75 ****
  #if !(KLH10_NET_NIT || KLH10_NET_DLPI || KLH10_NET_BPF || KLH10_NET_PFLT || \
  	KLH10_NET_TUN || KLH10_NET_LNX)
      /* None explicitly specified, pick a reasonable default */
! # if (CENV_SYS_FREEBSD && OSN_USE_IPONLY)
  #  undef  KLH10_NET_TUN
  #  define KLH10_NET_TUN 1
  # elif (CENV_SYS_NETBSD || CENV_SYS_FREEBSD)
--- 69,75 ----
  #if !(KLH10_NET_NIT || KLH10_NET_DLPI || KLH10_NET_BPF || KLH10_NET_PFLT || \
  	KLH10_NET_TUN || KLH10_NET_LNX)
      /* None explicitly specified, pick a reasonable default */
! # if ((CENV_SYS_FREEBSD || CENV_SYS_LINUX) && OSN_USE_IPONLY)
  #  undef  KLH10_NET_TUN
  #  define KLH10_NET_TUN 1
  # elif (CENV_SYS_NETBSD || CENV_SYS_FREEBSD)
***************
*** 146,151 ****
--- 146,154 ----
  #  include <linux/if_packet.h>
  #  include <linux/if_ether.h>   /* The L2 protocols */
  # endif
+ 
+ #elif KLH10_NET_TUN && CENV_SYS_LINUX /* [BV: tun support for Linux] */
+ # include <linux/if_tun.h>
  #endif
  
  
***************
*** 379,384 ****
--- 382,388 ----
  	int osnpf_rdtmo;	/* Read timeout, if any */
  	int osnpf_backlog;	/* Allow # backlogged packets, if any */
  	union ipaddr osnpf_ip;		/* IP address to use */
+ 	union ipaddr osnpf_tun;		/* INOUT: IP address of tunnel */
  	struct ether_addr osnpf_ea;	/* OUT: ether address of ifc */
  };
  int osn_pfinit(struct osnpf *, void *);
